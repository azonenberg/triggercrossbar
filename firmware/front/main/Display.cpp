/***********************************************************************************************************************
*                                                                                                                      *
* trigger-crossbar                                                                                                     *
*                                                                                                                      *
* Copyright (c) 2023-2024 Andrew D. Zonenberg and contributors                                                         *
* All rights reserved.                                                                                                 *
*                                                                                                                      *
* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the     *
* following conditions are met:                                                                                        *
*                                                                                                                      *
*    * Redistributions of source code must retain the above copyright notice, this list of conditions, and the         *
*      following disclaimer.                                                                                           *
*                                                                                                                      *
*    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the       *
*      following disclaimer in the documentation and/or other materials provided with the distribution.                *
*                                                                                                                      *
*    * Neither the name of the author nor the names of any contributors may be used to endorse or promote products     *
*      derived from this software without specific prior written permission.                                           *
*                                                                                                                      *
* THIS SOFTWARE IS PROVIDED BY THE AUTHORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   *
* TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL *
* THE AUTHORS BE HELD LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES        *
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR       *
* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT *
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE       *
* POSSIBILITY OF SUCH DAMAGE.                                                                                          *
*                                                                                                                      *
***********************************************************************************************************************/

#include "frontpanel.h"
#include "Display.h"
#include <math.h>

//based on https://www.eevblog.com/forum/projects/5x7-or-7x9-dot-matrix-font-files-in-cc/msg3946252/#msg3946252
static const uint8_t g_bitmapFont5x8[] =
{
	0x00, 0x00, 0x00, 0x00, 0x00,
	0x3E, 0x5B, 0x4F, 0x5B, 0x3E,
	0x3E, 0x6B, 0x4F, 0x6B, 0x3E,
	0x1C, 0x3E, 0x7C, 0x3E, 0x1C,
	0x18, 0x3C, 0x7E, 0x3C, 0x18,
	0x1C, 0x57, 0x7D, 0x57, 0x1C,
	0x1C, 0x5E, 0x7F, 0x5E, 0x1C,
	0x00, 0x18, 0x3C, 0x18, 0x00,
	0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
	0x00, 0x18, 0x24, 0x18, 0x00,
	0xFF, 0xE7, 0xDB, 0xE7, 0xFF,
	0x30, 0x48, 0x3A, 0x06, 0x0E,
	0x26, 0x29, 0x79, 0x29, 0x26,
	0x40, 0x7F, 0x05, 0x05, 0x07,
	0x40, 0x7F, 0x05, 0x25, 0x3F,
	0x5A, 0x3C, 0xE7, 0x3C, 0x5A,
	0x7F, 0x3E, 0x1C, 0x1C, 0x08,
	0x08, 0x1C, 0x1C, 0x3E, 0x7F,
	0x14, 0x22, 0x7F, 0x22, 0x14,
	0x5F, 0x5F, 0x00, 0x5F, 0x5F,
	0x06, 0x09, 0x7F, 0x01, 0x7F,
	0x00, 0x66, 0x89, 0x95, 0x6A,
	0x60, 0x60, 0x60, 0x60, 0x60,
	0x94, 0xA2, 0xFF, 0xA2, 0x94,
	0x08, 0x04, 0x7E, 0x04, 0x08,
	0x10, 0x20, 0x7E, 0x20, 0x10,
	0x08, 0x08, 0x2A, 0x1C, 0x08,
	0x08, 0x1C, 0x2A, 0x08, 0x08,
	0x1E, 0x10, 0x10, 0x10, 0x10,
	0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
	0x30, 0x38, 0x3E, 0x38, 0x30,
	0x06, 0x0E, 0x3E, 0x0E, 0x06,
	0x00, 0x00, 0x00, 0x00, 0x00,   // Space
	0x00, 0x00, 0x5F, 0x00, 0x00,
	0x00, 0x07, 0x00, 0x07, 0x00,
	0x14, 0x7F, 0x14, 0x7F, 0x14,
	0x24, 0x2A, 0x7F, 0x2A, 0x12,
	0x23, 0x13, 0x08, 0x64, 0x62,
	0x36, 0x49, 0x56, 0x20, 0x50,
	0x00, 0x08, 0x07, 0x03, 0x00,
	0x00, 0x1C, 0x22, 0x41, 0x00,
	0x00, 0x41, 0x22, 0x1C, 0x00,
	0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
	0x08, 0x08, 0x3E, 0x08, 0x08,
	0x00, 0x80, 0x70, 0x30, 0x00,
	0x08, 0x08, 0x08, 0x08, 0x08,
	0x00, 0x00, 0x60, 0x60, 0x00,
	0x20, 0x10, 0x08, 0x04, 0x02,
	0x3E, 0x51, 0x49, 0x45, 0x3E,
	0x00, 0x42, 0x7F, 0x40, 0x00,
	0x72, 0x49, 0x49, 0x49, 0x46,
	0x21, 0x41, 0x49, 0x4D, 0x33,
	0x18, 0x14, 0x12, 0x7F, 0x10,
	0x27, 0x45, 0x45, 0x45, 0x39,
	0x3C, 0x4A, 0x49, 0x49, 0x31,
	0x41, 0x21, 0x11, 0x09, 0x07,
	0x36, 0x49, 0x49, 0x49, 0x36,
	0x46, 0x49, 0x49, 0x29, 0x1E,
	0x00, 0x00, 0x14, 0x00, 0x00,
	0x00, 0x40, 0x34, 0x00, 0x00,
	0x00, 0x08, 0x14, 0x22, 0x41,
	0x14, 0x14, 0x14, 0x14, 0x14,
	0x00, 0x41, 0x22, 0x14, 0x08,
	0x02, 0x01, 0x59, 0x09, 0x06,
	0x3E, 0x41, 0x5D, 0x59, 0x4E,
	0x7C, 0x12, 0x11, 0x12, 0x7C,
	0x7F, 0x49, 0x49, 0x49, 0x36,
	0x3E, 0x41, 0x41, 0x41, 0x22,
	0x7F, 0x41, 0x41, 0x41, 0x3E,
	0x7F, 0x49, 0x49, 0x49, 0x41,
	0x7F, 0x09, 0x09, 0x09, 0x01,
	0x3E, 0x41, 0x41, 0x51, 0x73,
	0x7F, 0x08, 0x08, 0x08, 0x7F,
	0x00, 0x41, 0x7F, 0x41, 0x00,
	0x20, 0x40, 0x41, 0x3F, 0x01,
	0x7F, 0x08, 0x14, 0x22, 0x41,
	0x7F, 0x40, 0x40, 0x40, 0x40,
	0x7F, 0x02, 0x1C, 0x02, 0x7F,
	0x7F, 0x04, 0x08, 0x10, 0x7F,
	0x3E, 0x41, 0x41, 0x41, 0x3E,
	0x7F, 0x09, 0x09, 0x09, 0x06,
	0x3E, 0x41, 0x51, 0x21, 0x5E,
	0x7F, 0x09, 0x19, 0x29, 0x46,
	0x26, 0x49, 0x49, 0x49, 0x32,
	0x03, 0x01, 0x7F, 0x01, 0x03,
	0x3F, 0x40, 0x40, 0x40, 0x3F,
	0x1F, 0x20, 0x40, 0x20, 0x1F,
	0x3F, 0x40, 0x38, 0x40, 0x3F,
	0x63, 0x14, 0x08, 0x14, 0x63,
	0x03, 0x04, 0x78, 0x04, 0x03,
	0x61, 0x59, 0x49, 0x4D, 0x43,
	0x00, 0x7F, 0x41, 0x41, 0x41,
	0x02, 0x04, 0x08, 0x10, 0x20,
	0x00, 0x41, 0x41, 0x41, 0x7F,
	0x04, 0x02, 0x01, 0x02, 0x04,
	0x40, 0x40, 0x40, 0x40, 0x40,
	0x00, 0x03, 0x07, 0x08, 0x00,
	0x20, 0x54, 0x54, 0x78, 0x40,
	0x7F, 0x28, 0x44, 0x44, 0x38,
	0x38, 0x44, 0x44, 0x44, 0x28,
	0x38, 0x44, 0x44, 0x28, 0x7F,
	0x38, 0x54, 0x54, 0x54, 0x18,
	0x00, 0x08, 0x7E, 0x09, 0x02,
	0x18, 0xA4, 0xA4, 0x9C, 0x78,
	0x7F, 0x08, 0x04, 0x04, 0x78,
	0x00, 0x44, 0x7D, 0x40, 0x00,
	0x20, 0x40, 0x40, 0x3D, 0x00,
	0x7F, 0x10, 0x28, 0x44, 0x00,
	0x00, 0x41, 0x7F, 0x40, 0x00,
	0x7C, 0x04, 0x78, 0x04, 0x78,
	0x7C, 0x08, 0x04, 0x04, 0x78,
	0x38, 0x44, 0x44, 0x44, 0x38,
	0xFC, 0x18, 0x24, 0x24, 0x18,
	0x18, 0x24, 0x24, 0x18, 0xFC,
	0x7C, 0x08, 0x04, 0x04, 0x08,
	0x48, 0x54, 0x54, 0x54, 0x24,
	0x04, 0x04, 0x3F, 0x44, 0x24,
	0x3C, 0x40, 0x40, 0x20, 0x7C,
	0x1C, 0x20, 0x40, 0x20, 0x1C,
	0x3C, 0x40, 0x30, 0x40, 0x3C,
	0x44, 0x28, 0x10, 0x28, 0x44,
	0x4C, 0x90, 0x90, 0x90, 0x7C,
	0x44, 0x64, 0x54, 0x4C, 0x44,
	0x00, 0x08, 0x36, 0x41, 0x00,
	0x00, 0x00, 0x77, 0x00, 0x00,
	0x00, 0x41, 0x36, 0x08, 0x00,
	0x02, 0x01, 0x02, 0x04, 0x02,
	0x3C, 0x26, 0x23, 0x26, 0x3C,
	0x1E, 0xA1, 0xA1, 0x61, 0x12,
	0x3A, 0x40, 0x40, 0x20, 0x7A,
	0x38, 0x54, 0x54, 0x55, 0x59,
	0x21, 0x55, 0x55, 0x79, 0x41,
	0x21, 0x54, 0x54, 0x78, 0x41,
	0x21, 0x55, 0x54, 0x78, 0x40,
	0x20, 0x54, 0x55, 0x79, 0x40,
	0x0C, 0x1E, 0x52, 0x72, 0x12,
	0x39, 0x55, 0x55, 0x55, 0x59,
	0x39, 0x54, 0x54, 0x54, 0x59,
	0x39, 0x55, 0x54, 0x54, 0x58,
	0x00, 0x00, 0x45, 0x7C, 0x41,
	0x00, 0x02, 0x45, 0x7D, 0x42,
	0x00, 0x01, 0x45, 0x7C, 0x40,
	0xF0, 0x29, 0x24, 0x29, 0xF0,
	0xF0, 0x28, 0x25, 0x28, 0xF0,
	0x7C, 0x54, 0x55, 0x45, 0x00,
	0x20, 0x54, 0x54, 0x7C, 0x54,
	0x7C, 0x0A, 0x09, 0x7F, 0x49,
	0x32, 0x49, 0x49, 0x49, 0x32,
	0x32, 0x48, 0x48, 0x48, 0x32,
	0x32, 0x4A, 0x48, 0x48, 0x30,
	0x3A, 0x41, 0x41, 0x21, 0x7A,
	0x3A, 0x42, 0x40, 0x20, 0x78,
	0x00, 0x9D, 0xA0, 0xA0, 0x7D,
	0x39, 0x44, 0x44, 0x44, 0x39,
	0x3D, 0x40, 0x40, 0x40, 0x3D,
	0x3C, 0x24, 0xFF, 0x24, 0x24,
	0x48, 0x7E, 0x49, 0x43, 0x66,
	0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
	0xFF, 0x09, 0x29, 0xF6, 0x20,
	0xC0, 0x88, 0x7E, 0x09, 0x03,
	0x20, 0x54, 0x54, 0x79, 0x41,
	0x00, 0x00, 0x44, 0x7D, 0x41,
	0x30, 0x48, 0x48, 0x4A, 0x32,
	0x38, 0x40, 0x40, 0x22, 0x7A,
	0x00, 0x7A, 0x0A, 0x0A, 0x72,
	0x7D, 0x0D, 0x19, 0x31, 0x7D,
	0x26, 0x29, 0x29, 0x2F, 0x28,
	0x26, 0x29, 0x29, 0x29, 0x26,
	0x30, 0x48, 0x4D, 0x40, 0x20,
	0x38, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x38,
	0x2F, 0x10, 0xC8, 0xAC, 0xBA,
	0x2F, 0x10, 0x28, 0x34, 0xFA,
	0x00, 0x00, 0x7B, 0x00, 0x00,
	0x08, 0x14, 0x2A, 0x14, 0x22,
	0x22, 0x14, 0x2A, 0x14, 0x08,
	0xAA, 0x00, 0x55, 0x00, 0xAA,
	0xAA, 0x55, 0xAA, 0x55, 0xAA,
	0x00, 0x00, 0x00, 0xFF, 0x00,
	0x10, 0x10, 0x10, 0xFF, 0x00,
	0x14, 0x14, 0x14, 0xFF, 0x00,
	0x10, 0x10, 0xFF, 0x00, 0xFF,
	0x10, 0x10, 0xF0, 0x10, 0xF0,
	0x14, 0x14, 0x14, 0xFC, 0x00,
	0x14, 0x14, 0xF7, 0x00, 0xFF,
	0x00, 0x00, 0xFF, 0x00, 0xFF,
	0x14, 0x14, 0xF4, 0x04, 0xFC,
	0x14, 0x14, 0x17, 0x10, 0x1F,
	0x10, 0x10, 0x1F, 0x10, 0x1F,
	0x14, 0x14, 0x14, 0x1F, 0x00,
	0x10, 0x10, 0x10, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x1F, 0x10,
	0x10, 0x10, 0x10, 0x1F, 0x10,
	0x10, 0x10, 0x10, 0xF0, 0x10,
	0x00, 0x00, 0x00, 0xFF, 0x10,
	0x10, 0x10, 0x10, 0x10, 0x10,
	0x10, 0x10, 0x10, 0xFF, 0x10,
	0x00, 0x00, 0x00, 0xFF, 0x14,
	0x00, 0x00, 0xFF, 0x00, 0xFF,
	0x00, 0x00, 0x1F, 0x10, 0x17,
	0x00, 0x00, 0xFC, 0x04, 0xF4,
	0x14, 0x14, 0x17, 0x10, 0x17,
	0x14, 0x14, 0xF4, 0x04, 0xF4,
	0x00, 0x00, 0xFF, 0x00, 0xF7,
	0x14, 0x14, 0x14, 0x14, 0x14,
	0x14, 0x14, 0xF7, 0x00, 0xF7,
	0x14, 0x14, 0x14, 0x17, 0x14,
	0x10, 0x10, 0x1F, 0x10, 0x1F,
	0x14, 0x14, 0x14, 0xF4, 0x14,
	0x10, 0x10, 0xF0, 0x10, 0xF0,
	0x00, 0x00, 0x1F, 0x10, 0x1F,
	0x00, 0x00, 0x00, 0x1F, 0x14,
	0x00, 0x00, 0x00, 0xFC, 0x14,
	0x00, 0x00, 0xF0, 0x10, 0xF0,
	0x10, 0x10, 0xFF, 0x10, 0xFF,
	0x14, 0x14, 0x14, 0xFF, 0x14,
	0x10, 0x10, 0x10, 0x1F, 0x00,
	0x00, 0x00, 0x00, 0xF0, 0x10,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
	0xFF, 0xFF, 0xFF, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xFF, 0xFF,
	0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
	0x38, 0x44, 0x44, 0x38, 0x44,
	0x7C, 0x2A, 0x2A, 0x3E, 0x14,
	0x7E, 0x02, 0x02, 0x06, 0x06,
	0x02, 0x7E, 0x02, 0x7E, 0x02,
	0x63, 0x55, 0x49, 0x41, 0x63,
	0x38, 0x44, 0x44, 0x3C, 0x04,
	0x40, 0x7E, 0x20, 0x1E, 0x20,
	0x06, 0x02, 0x7E, 0x02, 0x02,
	0x99, 0xA5, 0xE7, 0xA5, 0x99,
	0x1C, 0x2A, 0x49, 0x2A, 0x1C,
	0x4C, 0x72, 0x01, 0x72, 0x4C,
	0x30, 0x4A, 0x4D, 0x4D, 0x30,
	0x30, 0x48, 0x78, 0x48, 0x30,
	0xBC, 0x62, 0x5A, 0x46, 0x3D,
	0x3E, 0x49, 0x49, 0x49, 0x00,
	0x7E, 0x01, 0x01, 0x01, 0x7E,
	0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
	0x44, 0x44, 0x5F, 0x44, 0x44,
	0x40, 0x51, 0x4A, 0x44, 0x40,
	0x40, 0x44, 0x4A, 0x51, 0x40,
	0x00, 0x00, 0xFF, 0x01, 0x03,
	0xE0, 0x80, 0xFF, 0x00, 0x00,
	0x08, 0x08, 0x6B, 0x6B, 0x08,
	0x36, 0x12, 0x36, 0x24, 0x36,
	0x06, 0x0F, 0x09, 0x0F, 0x06,
	0x00, 0x00, 0x18, 0x18, 0x00,
	0x00, 0x00, 0x10, 0x10, 0x00,
	0x30, 0x40, 0xFF, 0x01, 0x01,
	0x00, 0x1F, 0x01, 0x01, 0x1E,
	0x00, 0x19, 0x1D, 0x17, 0x12,
	0x00, 0x3C, 0x3C, 0x3C, 0x3C,
	0x00, 0x00, 0x00, 0x00, 0x00,
};

//8x16 character cell
struct CharacterCell8x15
{
	uint8_t pixels[15];
};

//8x16 bitmap font based on https://github.com/kmar/Sweet16Font/blob/master/Sweet16mono_bmfont_0.png
//Shrunk slightly (last blank row of pixels deleted to get an 8x15 cell size)
//Need to specify section!
//For some reason gcc was trying to put it in .data, not .rodata.
static const CharacterCell8x15 g_bitmapFont8x16[256] __attribute__((section(".rodata"))) =
{
	{ 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 },		//00-07
	{ 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 },		//08-0f
	{ 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 },		//10-17
	{ 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 },		//18-1f

	{ 0 },																							//0x20 = ' '
	{ 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00 },	//0x21 = '!'
	{ 0x00, 0x00, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	//0x22 = '"'
	{ 0x00, 0x00, 0x00, 0x24, 0x24, 0x7e, 0x24, 0x24, 0x24, 0x7e, 0x24, 0x24, 0x00, 0x00, 0x00 },	//0x23 = '#'
	{ 0x00, 0x08, 0x1c, 0x22, 0x22, 0x02, 0x1c, 0x20, 0x20, 0x22, 0x22, 0x1c, 0x08, 0x00, 0x00 },	//0x24 = '$'
	{ 0x00, 0x00, 0x02, 0x05, 0x45, 0x22, 0x10, 0x08, 0x04, 0x22, 0x51, 0x50, 0x20, 0x00, 0x00 },	//0x25 = '%'
	{ 0x00, 0x00, 0x0c, 0x12, 0x12, 0x12, 0x4c, 0x4a, 0x31, 0x21, 0x31, 0x4e, 0x00, 0x00, 0x00 },	//0x26 = '&'
	{ 0x00, 0x00, 0x10, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	//0x27 = '''
	{ 0x00, 0x00, 0x10, 0x08, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x10, 0x00, 0x00 },	//0x28 = '('
	{ 0x00, 0x00, 0x04, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x08, 0x04, 0x00, 0x00 },	//0x29 = ')'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x18, 0x7e, 0x18, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00 },	//0x2a = '*'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x3e, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00 },	//0x2b = '+'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x08, 0x00, 0x00 },	//0x2c = ','
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	//0x2d = '-'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00 },	//0x2e = '.'
	{ 0x00, 0x00, 0x20, 0x20, 0x10, 0x10, 0x08, 0x08, 0x04, 0x04, 0x02, 0x02, 0x00, 0x00, 0x00 },	//0x2f = '/'

	{ 0x00, 0x00, 0x3c, 0x42, 0x62, 0x52, 0x52, 0x4a, 0x4a, 0x46, 0x42, 0x3c, 0x00, 0x00, 0x00 },	//0x30 = '0'
	{ 0x00, 0x00, 0x20, 0x30, 0x28, 0x24, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00 },	//0x31 = '1'
	{ 0x00, 0x00, 0x3c, 0x42, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x02, 0x7e, 0x00, 0x00, 0x00 },	//0x32 = '2'
	{ 0x00, 0x00, 0x3c, 0x42, 0x40, 0x40, 0x38, 0x40, 0x40, 0x40, 0x42, 0x3c, 0x00, 0x00, 0x00 },	//0x33 = '3'
	{ 0x00, 0x00, 0x20, 0x30, 0x28, 0x24, 0x22, 0x7e, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00 },	//0x34 = '4'
	{ 0x00, 0x00, 0x7e, 0x02, 0x02, 0x02, 0x3e, 0x40, 0x40, 0x40, 0x42, 0x3c, 0x00, 0x00, 0x00 },	//0x35 = '5'
	{ 0x00, 0x00, 0x38, 0x04, 0x02, 0x02, 0x3e, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00 },	//0x36 = '6'
	{ 0x00, 0x00, 0x7e, 0x40, 0x40, 0x40, 0x20, 0x10, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00 },	//0x37 = '7'
	{ 0x00, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00 },	//0x38 = '8'
	{ 0x00, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x7c, 0x40, 0x40, 0x40, 0x42, 0x3c, 0x00, 0x00, 0x00 },	//0x39 = '9'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00 },	//0x3a = ':'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x10, 0x10, 0x08, 0x00, 0x00 },	//0x3b = ';'
	{ 0x00, 0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00, 0x00 },	//0x3c = '<'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	//0x3d = '='
	{ 0x00, 0x00, 0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x00 },	//0x3e = '>'
	{ 0x00, 0x00, 0x3c, 0x42, 0x42, 0x40, 0x20, 0x10, 0x08, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00 },	//0x3f = '?'

	{ 0x00, 0x00, 0x00, 0x3c, 0x42, 0x99, 0xa1, 0xb9, 0xa5, 0x79, 0x02, 0x7c, 0x00, 0x00, 0x00 },	//0x40 = '@'
	{ 0x00, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00 },	//0x41 = 'A'
	{ 0x00, 0x00, 0x3e, 0x42, 0x42, 0x42, 0x3e, 0x42, 0x42, 0x42, 0x42, 0x3e, 0x00, 0x00, 0x00 },	//0x42 = 'B'
	{ 0x00, 0x00, 0x3c, 0x42, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x42, 0x3c, 0x00, 0x00, 0x00 },	//0x43 = 'C'
	{ 0x00, 0x00, 0x1e, 0x22, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x22, 0x1e, 0x00, 0x00, 0x00 },	//0x44 = 'D'
	{ 0x00, 0x00, 0x7e, 0x02, 0x02, 0x02, 0x1e, 0x02, 0x02, 0x02, 0x02, 0x7e, 0x00, 0x00, 0x00 },	//0x45 = 'E'
	{ 0x00, 0x00, 0x7e, 0x02, 0x02, 0x02, 0x1e, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00 },	//0x46 = 'F'
	{ 0x00, 0x00, 0x3c, 0x42, 0x02, 0x02, 0x02, 0x72, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00 },	//0x47 = 'G'
	{ 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00 },	//0x48 = 'H'
	{ 0x00, 0x00, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x00, 0x00, 0x00 },	//0x49 = 'I'
	{ 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00 },	//0x4a = 'J'
	{ 0x00, 0x00, 0x42, 0x42, 0x22, 0x12, 0x0e, 0x12, 0x22, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00 },	//0x4b = 'K'
	{ 0x00, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x7e, 0x00, 0x00, 0x00 },	//0x4c = 'L'
	{ 0x00, 0x00, 0x41, 0x63, 0x55, 0x49, 0x49, 0x41, 0x41, 0x41, 0x41, 0x41, 0x00, 0x00, 0x00 },	//0x4d = 'M'
	{ 0x00, 0x00, 0x42, 0x46, 0x4a, 0x52, 0x62, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00 },	//0x4e = 'N'
	{ 0x00, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00 },	//0x4f = 'O'

	{ 0x00, 0x00, 0x3e, 0x42, 0x42, 0x42, 0x3e, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00 },	//0x50 = 'P'
	{ 0x00, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x52, 0x62, 0x7c, 0x40, 0x00, 0x00 },	//0x51 = 'Q'
	{ 0x00, 0x00, 0x3e, 0x42, 0x42, 0x42, 0x3e, 0x22, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00 },	//0x52 = 'R'
	{ 0x00, 0x00, 0x3c, 0x42, 0x02, 0x04, 0x18, 0x20, 0x40, 0x40, 0x42, 0x3c, 0x00, 0x00, 0x00 },	//0x53 = 'S'
	{ 0x00, 0x00, 0x7f, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00 },	//0x54 = 'T'
	{ 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00 },	//0x55 = 'U'
	{ 0x00, 0x00, 0x41, 0x41, 0x41, 0x41, 0x22, 0x22, 0x14, 0x14, 0x08, 0x08, 0x00, 0x00, 0x00 },	//0x56 = 'V'
	{ 0x00, 0x00, 0x41, 0x41, 0x41, 0x41, 0x49, 0x49, 0x49, 0x55, 0x63, 0x41, 0x00, 0x00, 0x00 },	//0x57 = 'W'
	{ 0x00, 0x00, 0x42, 0x42, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00 },	//0x58 = 'X'
	{ 0x00, 0x00, 0x41, 0x41, 0x22, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00 },	//0x59 = 'Y'
	{ 0x00, 0x00, 0x7e, 0x40, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x02, 0x7e, 0x00, 0x00, 0x00 },	//0x5a = 'Z'
	{ 0x00, 0x00, 0x1c, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1c, 0x00, 0x00 },	//0x5b = '['
	{ 0x00, 0x00, 0x02, 0x02, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10, 0x20, 0x20, 0x00, 0x00, 0x00 },	//0x5c = '\'
	{ 0x00, 0x00, 0x1c, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1c, 0x00, 0x00 },	//0x5d = ']'
	{ 0x00, 0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	//0x5e = '^'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00 },	//0x5f = '_'

	{ 0x00, 0x00, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },	//0x60 = '`'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x40, 0x7c, 0x42, 0x42, 0x42, 0x7c, 0x00, 0x00, 0x00 },	//0x61 = 'a'
	{ 0x00, 0x00, 0x02, 0x02, 0x02, 0x3e, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3e, 0x00, 0x00, 0x00 },	//0x62 = 'b'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x42, 0x02, 0x02, 0x02, 0x42, 0x3c, 0x00, 0x00, 0x00 },	//0x63 = 'c'
	{ 0x00, 0x00, 0x40, 0x40, 0x40, 0x7c, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7c, 0x00, 0x00, 0x00 },	//0x64 = 'd
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x42, 0x42, 0x7e, 0x02, 0x42, 0x3c, 0x00, 0x00, 0x00 },	//0x65 = 'e'
	{ 0x00, 0x00, 0x38, 0x44, 0x04, 0x04, 0x1e, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00 },	//0x66 = 'f'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x62, 0x5c, 0x40, 0x42, 0x3c },	//0x67 = 'g'
	{ 0x00, 0x00, 0x02, 0x02, 0x02, 0x3e, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00 },	//0x68 = 'h'
	{ 0x00, 0x00, 0x00, 0x08, 0x00, 0x0e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x00, 0x00, 0x00 },	//0x69 = 'i'
	{ 0x00, 0x00, 0x00, 0x20, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x22, 0x1c },	//0x6a = 'j'
	{ 0x00, 0x00, 0x02, 0x02, 0x02, 0x42, 0x42, 0x22, 0x1e, 0x22, 0x42, 0x42, 0x00, 0x00, 0x00 },	//0x6b = 'k'
	{ 0x00, 0x00, 0x0e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x00, 0x00, 0x00 },	//0x6c = 'l'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x49, 0x49, 0x49, 0x49, 0x49, 0x41, 0x00, 0x00, 0x00 },	//0x6d = 'm'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00 },	//0x6e = 'n'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00 },	//0x6f = 'o'

	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3e, 0x02, 0x02, 0x02 },	//0x70 = 'p'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7c, 0x40, 0x40, 0x40 },	//0x71 = 'q'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x06, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00 },	//0x72 = 'r'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x42, 0x02, 0x3c, 0x40, 0x42, 0x3c, 0x00, 0x00, 0x00 },	//0x73 = 's'
	{ 0x00, 0x00, 0x00, 0x08, 0x08, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x30, 0x00, 0x00, 0x00 },	//0x74 = 't'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7c, 0x00, 0x00, 0x00 },	//0x75 = 'u'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x41, 0x22, 0x22, 0x14, 0x14, 0x08, 0x00, 0x00, 0x00 },	//0x76 = 'v'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x41, 0x49, 0x49, 0x49, 0x55, 0x22, 0x00, 0x00, 0x00 },	//0x77 = 'w'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x22, 0x14, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00 },	//0x78 = 'x'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x62, 0x5c, 0x40, 0x20, 0x1e },	//0x79 = 'y'
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x20, 0x10, 0x08, 0x04, 0x02, 0x7e, 0x00, 0x00, 0x00 },	//0x7a = 'z'
	{ 0x00, 0x00, 0x30, 0x08, 0x08, 0x08, 0x08, 0x06, 0x08, 0x08, 0x08, 0x08, 0x30, 0x00, 0x00 },	//0x7b = '{'
	{ 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00 },	//0x7c = '|'
	{ 0x00, 0x00, 0x06, 0x08, 0x08, 0x08, 0x08, 0x30, 0x08, 0x08, 0x08, 0x08, 0x06, 0x00, 0x00 },	//0x7d = '}'
	{ 0x00, 0x00, 0x4c, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }	//0x7e = '~'
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Construction / destruction

Display::Display(DisplaySPIType* spi, GPIOPin* busy_n, GPIOPin* cs_n, GPIOPin* dc, GPIOPin* rst)
	: m_spi(spi)
	, m_busy_n(busy_n)
	, m_cs_n(cs_n)
	, m_dc(dc)
	, m_rst_n(rst)
	, m_width(212)
	, m_height(104)
	, m_refreshState(STATE_IDLE)
{
	//Deassert SPI CS#
	*m_cs_n = 1;

	g_log("Resetting display\n");
	g_logTimer.Sleep(1000);

	//Reset the display, need 5ms between each cycle
	*m_rst_n = 1;
	g_logTimer.Sleep(500);
	*m_rst_n = 0;
	g_logTimer.Sleep(500);
	*m_rst_n = 1;
	g_logTimer.Sleep(500);

	//wait for busy to clear

	//Soft reset
	SendCommand(0x00);
	SendData(0x0e);
	g_logTimer.Sleep(500);

	//Clear both bitplanes to blank
	Clear();
	Clear();

	//Read the OTP data
	g_log("Reading OTP...\n");
	g_logTimer.Sleep(500);
	LogIndenter li(g_log);
	SendCommand(0xa2);
	g_logTimer.Sleep(500);
	ReadData();	//dummy cycle before valid data
	int activeBank = 0;
	for(int i=0; ; i++)
	{
		auto ret = ReadData();

		//After reading the 0th address, we know what addresses the other PSRs are at
		if(i == 0)
		{
			if(ret == 0xa5)
				activeBank = 0;
			else
				activeBank = 1;

			g_log("Active OTP bank = %d\n", activeBank);
		}

		if(i == 0xc00)
		{
			if( (activeBank == 1) && (ret != 0xa5) )
			{
				g_log("Not seeing good data on OTP bank 1 either (ret = %02x), using defaults\n", ret);
				m_psr0 = 0xcf;
				m_psr1 = 0x02;
				activeBank = 2;
				break;
			}
		}

		if(activeBank == 0)
		{
			//seems there's an off-by-one where we count bytes since the 0xa5, so a5 isn't zero?
			if(i == 0xb1c)
				m_psr0 = ret;
			if(i == 0xb1d)
			{
				m_psr1 = ret;
				break;
			}
		}

		else if(activeBank == 1)
		{
			if(i == 0x171c)
				m_psr0 = ret;
			if(i == 0x171d)
			{
				m_psr1 = ret;
				break;
			}
		}
	}

	//TODO: we sometimes read this wrong
	//m_psr0 = 0x02;
	//m_psr1 = 0xfc;
	m_psr0 = 0xcf;
	m_psr1 = 0x02;
	g_log("Done (psr0 = %02x, psr1 = %02x)\n", m_psr0, m_psr1);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// High level interface

/**
	@brief Copy the current framebuffer to the old, and reset it to blank
 */
void Display::Clear()
{
	memset(m_framebuffer, 0, sizeof(m_framebuffer));
}

/**
	@brief Draw an ASCII string

	With a 6x8 pixel font, we get 13 lines x 35.5 chars wide.
 */
void Display::Text6x8(int16_t x, int16_t y, const char* str, bool black)
{
	const int fontwidth = 5;
	const int fontheight = 8;
	const int lineheight = 8;

	int16_t xstart = x;

	while(*str != '\0')
	{
		char c = *str;

		//Handle newlines
		if(c == '\n')
		{
			x = xstart;
			y -= lineheight;
			if(y < 0)
				break;
			str ++;
			continue;
		}

		//Draw the actual character
		for(int16_t dx=0; dx<fontwidth; dx++)
		{
			uint8_t col = g_bitmapFont5x8[5*c + dx];

			for(int16_t dy=0; dy<fontheight; dy++)
			{
				if(col & (1 << dy) )
					SetPixel(x + dx, y + fontheight - dy, black);
			}
		}

		//Move to next character cell (no blank space included in this font)
		x += fontwidth + 1;

		//Line wrap to avoid going off edge of image
		if( (x + fontwidth) >= m_width)
		{
			x = xstart;
			y -= lineheight;
			if(y < 0)
				break;
		}

		//Next byte
		str ++;
	}
}

/**
	@brief Draw an ASCII string

	With an 8x16 pixel font, we get 6.5 lines x 26.5 chars wide.
 */
void Display::Text8x16(int16_t x, int16_t y, const char* str, bool black)
{
	const int fontwidth = 8;
	const int fontheight = 15;
	const int lineheight = 16;

	int16_t xstart = x;

	while(*str != '\0')
	{
		char c = *str;

		//Handle newlines
		if(c == '\n')
		{
			x = xstart;
			y -= lineheight;
			if(y < 0)
				break;
			str ++;
			continue;
		}

		//Draw the actual character
		auto& glyph = g_bitmapFont8x16[(int)c];
		for(int16_t dy=0; dy<fontheight; dy++)
		{
			uint8_t row = glyph.pixels[dy];
			for(int16_t dx=0; dx<fontwidth; dx++)
			{
				if(row & (1 << dx) )
					SetPixel(x + dx, y + fontheight - dy, black);
			}
		}

		//Move to next character cell
		x += fontwidth;

		//Line wrap to avoid going off edge of image
		if( (x + fontwidth) >= m_width)
		{
			x = xstart;
			y -= lineheight;
			if(y < 0)
				break;
		}

		//Next byte
		str ++;
	}
}

/**
	@brief Bresenham line drawing (based on pseudocode at https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm)
 */
void Display::Line(int16_t x0, int16_t y0, int16_t x1, int16_t y1, bool black)
{
	if(abs(y1 - y0) < abs(x1 - x0))
	{
		if(x0 > x1)
			LineLow(x1, y1, x0, y0, black);
		else
			LineLow(x0, y0, x1, y1, black);
	}
	else
	{
		if(y0 > y1)
			LineHigh(x1, y1, x0, y0, black);
		else
			LineHigh(x0, y0, x1, y1, black);
	}
}

/**
	@brief Shallow slope implementation
 */
void Display::LineLow(int16_t x0, int16_t y0, int16_t x1, int16_t y1, bool black)
{
	int16_t dx = x1 - x0;
	int16_t dy = y1 - y0;
	int16_t yi = 1;

	if(dy < 0)
	{
		yi = -1;
		dy = -dy;
	}

	int16_t d = 2*dy - dx;
	int16_t y = y0;

	for(int16_t x = x0; x<= x1; x++)
	{
		SetPixel(x, y, black);

		if(d > 0)
		{
			y += yi;
			d += 2*(dy-dx);
		}
		else
			d += 2*dy;
	}
}

/**
	@brief Steep slope implementation
 */
void Display::LineHigh(int16_t x0, int16_t y0, int16_t x1, int16_t y1, bool black)
{
	int16_t dx = x1 - x0;
	int16_t dy = y1 - y0;
	int16_t xi = 1;

	if(dx < 0)
	{
		xi = -1;
		dx = -dx;
	}

	int16_t d = 2*dx - dy;
	int16_t x = x0;

	for(int16_t y = y0; y<= y1; y++)
	{
		SetPixel(x, y, black);

		if(d > 0)
		{
			x += xi;
			d += 2*(dx-dy);
		}
		else
			d += 2*dx;
	}
}

/**
	@brief Axially aligned flood fill

	assumes x0 <= x1 and y0 <= y1 for now
 */
void Display::FilledRect(int16_t x0, int16_t y0, int16_t x1, int16_t y1, bool black)
{
	for(int16_t x=x0; x<=x1; x++)
	{
		for(int16_t y=y0; y<=y1; y++)
			SetPixel(x, y, black);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Mid level interface

/**
	@brief Sets a single pixel in the framebuffer
 */
void Display::SetPixel(uint8_t x, uint8_t y, bool black)
{
	//Image scan order: bottom left to top left is first scanline
	//bottom right to top right is last scanline
	//Total format is 104 pixels / 13 bytes per scanline, 212 scanlines
	//MSB of a byte is the lowest pixel

	//Start of the column
	uint16_t coloff = x * (m_height/8);

	//Bit and byte positions
	uint8_t nbyte = y / 8;
	uint8_t nbit = 7 - (y % 8);
	uint8_t bitmask = (1 << nbit);

	//Do the actual write operations
	if(black)
		m_framebuffer[coloff + nbyte] |= bitmask;
	else
		m_framebuffer[coloff + nbyte] &= ~bitmask;
}

/**
	@brief Called each iteration of the main loop
 */
void Display::OnTick()
{
	if(!IsRefreshInProgress())
		return;

	//See what needs doing
	switch(m_refreshState)
	{
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Fast path

		//Soft reset
		case STATE_REFRESH_FAST_INIT:
			g_log("fast refresh\n");

			SendCommand(0x00);
			SendData(0x0e);

			m_refreshState = STATE_REFRESH_FAST_INIT2;
			break;

		//Send initial commands
		case STATE_REFRESH_FAST_INIT2:
			if(*m_busy_n)
			{
				//Get temperature and clamp to valid range
				auto temp = ReadThermalSensor(g_tempI2cAddress);
				if(temp > 60)
					temp = 60;

				//Send temperature
				SendCommand(0xe5);
				SendData( (temp >> 8) + 0x40 );

				//Activate temperature
				SendCommand(0xe0);
				SendData(0x02);

				//Send panel settings
				SendCommand(0x00);
				SendData(m_psr0 | 0x10);
				SendData(m_psr1 | 0x02);

				//Vcom and data interval
				SendCommand(0x50);
				SendData(0x07);

				//Border setting
				SendCommand(0x50);
				SendData(0x27);

				m_refreshState = STATE_REFRESH_FAST_DATA0;
			}

			break;

		//Send old data
		case STATE_REFRESH_FAST_DATA0:
			SendCommand(0x10);
			for(int32_t i=0; i<2756; i++)
				SendData(m_oldFramebuffer[i]);

			m_refreshState = STATE_REFRESH_FAST_DATA1;
			break;

		//Send new data
		case STATE_REFRESH_FAST_DATA1:
			SendCommand(0x13);
			for(int32_t i=0; i<2756; i++)
				SendData(m_framebuffer[i]);

			m_refreshState = STATE_REFRESH_FINAL1;
			break;

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Slow path

		//Initialization for the slow refresh path
		case STATE_REFRESH_SLOW_INIT:
			g_log("slow refresh\n");
			{
				//Get temperature and clamp to valid range
				auto temp = ReadThermalSensor(g_tempI2cAddress);
				if(temp > 60)
					temp = 60;

				//Send temperature
				SendCommand(0xe5);
				SendData(temp >> 8);

				//Activate temperature
				SendCommand(0xe0);
				SendData(0x02);

				//Send panel settings
				SendCommand(0x00);
				SendData(m_psr0);
				SendData(m_psr1);

				m_refreshState = STATE_REFRESH_SLOW_DATA0;
			}
			break;

		//Send the first block of data
		case STATE_REFRESH_SLOW_DATA0:
			SendCommand(0x10);
			for(int32_t i=0; i<2756; i++)
				SendData(m_framebuffer[i]);

			m_refreshState = STATE_REFRESH_SLOW_DATA1;
			break;

		//Send zeroes
		case STATE_REFRESH_SLOW_DATA1:
			SendCommand(0x13);
			for(int32_t i=0; i<2756; i++)
				SendData(0x00);

			m_refreshState = STATE_REFRESH_FINAL1;
			break;

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Finish the refresh

		//Wait for busy state then send power-on command
		case STATE_REFRESH_FINAL1:

			if(*m_busy_n)
			{
				SendCommand(0x04);
				m_refreshState = STATE_REFRESH_FINAL2;
			}
			break;

		//Wait for busy state then send refresh command
		case STATE_REFRESH_FINAL2:
			if(*m_busy_n)
			{
				SendCommand(0x12);
				m_refreshState = STATE_REFRESH_FINAL3;
			}
			break;

		//Wait for refresh to complete then turn off DC-DC
		case STATE_REFRESH_FINAL3:
			if(*m_busy_n)
			{
				SendCommand(0x02);
				m_refreshState = STATE_REFRESH_FINAL4;
			}
			break;

		//Wait for DC-DC to turn off then save the framebuffer
		case STATE_REFRESH_FINAL4:
			if(*m_busy_n)
			{
				memcpy(m_oldFramebuffer, m_framebuffer, sizeof(m_framebuffer));

				SendCommand(0x00);
				SendData(0x0e);

				m_refreshState = STATE_IDLE;
			}
			break;

		default:
			break;
	}
}

/**
	@brief Push the framebuffer to the display
 */
void Display::StartRefresh(bool forceFullScreenUpdate)
{
	if(forceFullScreenUpdate)
		m_refreshState = STATE_REFRESH_SLOW_INIT;
	else
		m_refreshState = STATE_REFRESH_FAST_INIT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Low level interface

void Display::SendCommand(uint8_t cmd)
{
	*m_dc = 0;
	*m_cs_n = 0;

	m_spi->BlockingWrite(cmd);
	m_spi->WaitForWrites();
	m_spi->DiscardRxData();

	*m_cs_n = 1;
}

void Display::SendData(uint8_t data)
{
	*m_dc = 1;
	*m_cs_n = 0;

	m_spi->BlockingWrite(data);
	m_spi->WaitForWrites();
	m_spi->DiscardRxData();

	*m_cs_n = 1;
}

uint8_t Display::ReadData()
{
	*m_dc = 1;
	*m_cs_n = 0;

	auto ret = m_spi->BlockingRead();


	*m_cs_n = 1;
	return ret;
}
